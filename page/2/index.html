<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="ipfans's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="ipfans&#39;s Blog">
<meta property="og:url" content="https://ipfans.github.io/page/2/index.html">
<meta property="og:site_name" content="ipfans&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ipfans&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ipfans.github.io/page/2/"/>





  <title>ipfans's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b9862358b198078f40d7e1596b7c5968";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ipfans's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ipfans.github.io/2016/09/tracing-python-program-with-dtrace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/tracing-python-program-with-dtrace/" itemprop="url">使用 dtrace 跟踪 Python 应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-15T18:00:00+08:00">
                2016-09-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/tracing-python-program-with-dtrace/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/09/tracing-python-program-with-dtrace/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年在 Pycon China 上，来自饿了么的郭浩川分享了 <a href="http://ocgxshkaw.bkt.clouddn.com/4%20%E3%80%8A%E7%94%A8%E9%AB%98%E9%AD%94%E7%9A%84%E5%A7%BF%E5%8A%BF%E8%B0%83%20python%20%E7%A8%8B%E5%BA%8F%E3%80%8B%E9%83%AD%E6%B5%A9%E5%B7%9D.pdf" target="_blank" rel="external">利用 systemtap 进行 Python 执行情况分析</a> 的内容。分享利用 systemtap 在线上环境中实时监控 gevent patch 的 green thread 程序的执行状况。</p>
<p>dtrace 和 systemtap 均支持在 Linux 上进行分析，在 macOS 系统上则只有 dtrace 使用。在 Python3.5 和之前版本中，需要使用手工 Patch 的方式进行埋点监控。在 Python 3.6 以上中 dtrace 和 systemtap 埋点支持功能可以通过编译参数 –with-dtrace 开启。</p>
<h2 id="从-dtrace-开始"><a href="#从-dtrace-开始" class="headerlink" title="从 dtrace 开始"></a>从 dtrace 开始</h2><p>dtrace 是一个低开销的成本动态跟踪工具，可以通过埋点 probs 方式监控各项程序运行状态。dtrace 最初内置在 Solaris 系统中，因此我们可以借助 Solaris 系统的相关文档了解 dtrace 的基本操作。<a href="http://wenku.baidu.com/view/adb13ec7f61fb7360b4c65ad.html" target="_blank" rel="external">DTrace 用户指南</a> 是 Oracle 提供的基于 Solaris 系统的 dtrace 操作手册，操作基本与其它系统相同，推荐在最初开始阶段阅读该使用手册。</p>
<p>在 macOS 上，已经很多系统底层功能和 framework 中已经集成了 dtrace 的功能。</p>
<p>比如说我们需要监控 read 这个 syscall 的入口，可以通过下面这个命令实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo dtrace -n syscall::read:entry</div><div class="line"></div><div class="line">dtrace: description &apos;syscall::read:entry&apos; matched 1 probe</div><div class="line"></div><div class="line">CPU     ID                    FUNCTION:NAME</div><div class="line">  0    156                       read:entry</div><div class="line">  0    156                       read:entry</div><div class="line">  0    156                       read:entry</div><div class="line">...</div></pre></td></tr></table></figure>
<p>其中 <code>-n</code> 参数表示打印特定的 probs 内容的调用。现在这样仅仅显示了调用，但是调用的信息还是不详细的。这个时候就需要使用 dtrace 的脚本获取更多的信息。</p>
<h2 id="dtrace-的脚本"><a href="#dtrace-的脚本" class="headerlink" title="dtrace 的脚本"></a>dtrace 的脚本</h2><p>dtrace 的名字暗示了自己的脚本，dtrace 使用了 D 语言作为脚本语言（WTF）。这个时候就需要学习一下基础的 D 语言内容。dtrace 中 D 语言的使用，可以在上面提到的 dtrace 用户指南中的对应章节。</p>
<p>我们继续上一节中的例子，检测调用 read syscall 的参数内容。在进行操作之前，我们需要了解一下 read 的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> read(<span class="keyword">int</span> fildes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte);</div></pre></td></tr></table></figure>
<p>我们想知道调用来自于哪些进程，读取了多少字节。首先，我们需要创建一个叫 <code>syscall.d</code> 文件。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">syscall::read:entry</div><div class="line">&#123;printf (<span class="string">"%s called read, asking for %d bytes\n"</span>, execname, arg2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后通过命令行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo dtrace -s syscall.d</div><div class="line"></div><div class="line">dtrace: script &apos;syscall.d&apos; matched 1 probe</div><div class="line"></div><div class="line">CPU     ID                    FUNCTION:NAME</div><div class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</div><div class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</div><div class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</div><div class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</div><div class="line">  0    156                       read:entry iTerm2 called read, asking for 32 bytes</div><div class="line">  0    156                       read:entry iTerm2 called read, asking for 1024 bytes</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="从-dtrace-到-Python-跟踪"><a href="#从-dtrace-到-Python-跟踪" class="headerlink" title="从 dtrace 到 Python 跟踪"></a>从 dtrace 到 Python 跟踪</h2><p>在 Pycon 上的分享上，提供了一种 CPython 虚拟机代码 Patch 方式进行跟踪的方案，这种方案需要系统支持，比如 REHL 系列系统默认支持，假如你是用了 Ubuntu 系统，除了重新编译 CPython 以外没有其他办法。不过除此之外，还有一种更简单的方式，就是使用 <code>Python USDT</code>。但是值得注意的是 <code>Python USDT</code> 是一种用户态修饰器监控方法，这种方式与 patch CPython 的方式相比差距较大，毕竟 USDT 无法监控一些系统底层的尤其是涉及到比如 gevent 导致的上下文切换时的混乱。同样的，systemtap 也有一个专门的库：<a href="https://github.com/wooparadog/python-systemtap" target="_blank" rel="external">python-systemtap</a>。</p>
<p>不过还是从 USDT 开始。USDT 可以通过 pip 直接安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install usdt</div></pre></td></tr></table></figure>
<p>接下来用 ipython 演示一下 usdt 的基础使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">➜  ~ ipython</div><div class="line">Python 2.7.12 (default, Jul  4 2016, 11:33:35)</div><div class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line"></div><div class="line">IPython 5.0.0 -- An enhanced Interactive Python.</div><div class="line">?         -&gt; Introduction and overview of IPython&apos;s features.</div><div class="line">%quickref -&gt; Quick reference.</div><div class="line">help      -&gt; Python&apos;s own help system.</div><div class="line">object?   -&gt; Details about &apos;object&apos;, use &apos;object??&apos; for extra details.</div><div class="line"></div><div class="line">In [1]: import os</div><div class="line"></div><div class="line">In [2]: os.getpid()</div><div class="line">Out[2]: 7777</div><div class="line"></div><div class="line">In [3]: from usdt.tracer import fbt</div><div class="line"></div><div class="line">In [4]: @fbt</div><div class="line">   ...: def example(v):</div><div class="line">   ...:     pass</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [5]: example(&quot;hello&quot;)</div></pre></td></tr></table></figure>
<p>我们使用监听进程的方式监控来自于 usdt 的探针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo dtrace -l -p 7777 -m fbt</div><div class="line"></div><div class="line">   ID   PROVIDER            MODULE                          FUNCTION NAME</div><div class="line"> 1206 python-fbt7777               fbt                           example entry</div><div class="line"> 1207 python-fbt7777               fbt                           example return</div></pre></td></tr></table></figure>
<p>其中 <code>-p</code> 用于指定进程，<code>-m</code> 指定对应的模块。如果不进行模块过滤的话，你很有可能被很多相关的调试信息淹没。</p>
<p>在新版的 Python 3.6 以上版本中通过开启 <code>--with-dtrace</code> 开关的方式可以获取详细的 Python 运行状态信息，包括：</p>
<ul>
<li>函数调用与返回</li>
<li>GC 开始与结束</li>
<li>执行代码行数</li>
</ul>
<p>首先运行一个 Python 3.6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">➜  ~ ipython</div><div class="line">Python 3.6.0b1 (default, Sep 15 2016, 10:16:39)</div><div class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line"></div><div class="line">IPython 5.1.0 -- An enhanced Interactive Python.</div><div class="line">?         -&gt; Introduction and overview of IPython&apos;s features.</div><div class="line">%quickref -&gt; Quick reference.</div><div class="line">help      -&gt; Python&apos;s own help system.</div><div class="line">object?   -&gt; Details about &apos;object&apos;, use &apos;object??&apos; for extra details.</div><div class="line"></div><div class="line">In [1]: import os</div><div class="line"></div><div class="line">In [2]: os.getpid()</div><div class="line">Out[2]: 33164</div><div class="line"></div><div class="line">In [3]:</div></pre></td></tr></table></figure>
<p>接下来通过 dtrace 来获取所有的 Python 探针输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo dtrace -l -m python3.6</div><div class="line"></div><div class="line">   ID   PROVIDER            MODULE                          FUNCTION NAME</div><div class="line">35775 python33164         python3.6          _PyEval_EvalFrameDefault function-entry</div><div class="line">35776 python33164         python3.6          _PyEval_EvalFrameDefault function-return</div><div class="line">35777 python33164         python3.6                           collect gc-done</div><div class="line">35778 python33164         python3.6                           collect gc-start</div><div class="line">35779 python33164         python3.6          _PyEval_EvalFrameDefault line</div></pre></td></tr></table></figure>
<p>如果想要实现一个类似 pycon 中监控程序执行具体内容的 dtrace 脚本，请参考官方文档 <a href="https://docs.python.org/3.6/howto/instrumentation.html#instrumentation" target="_blank" rel="external">Instrumenting CPython with DTrace and SystemTap</a> 中的现成脚本即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>dtrace 提供了一种方便的、低干扰的 Python 内部执行探查方式。通过这种方式可以方便的了解目前 Python 的具体执行状况。同时，通过脚本，可以快速获取和定位相关想要了解的具体内容。当然，你也可以像郭浩川分享的那样，做一个比较炫酷的烈焰图。XD</p>
<p>[^systemtap]: <a href="http://ocgxshkaw.bkt.clouddn.com/4%20%E3%80%8A%E7%94%A8%E9%AB%98%E9%AD%94%E7%9A%84%E5%A7%BF%E5%8A%BF%E8%B0%83%20python%20%E7%A8%8B%E5%BA%8F%E3%80%8B%E9%83%AD%E6%B5%A9%E5%B7%9D.pdf" target="_blank" rel="external">利用 systemtap 进行 Python 执行情况分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ipfans.github.io/2016/08/introduce-traefik-load-balance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/introduce-traefik-load-balance/" itemprop="url">traefik 简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-01T11:00:00+08:00">
                2016-08-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/08/introduce-traefik-load-balance/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/08/introduce-traefik-load-balance/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>traefik(<a href="https://traefik.io/" target="_blank" rel="external">https://traefik.io/</a>) 是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。目前支持 Docker, Swarm, Mesos/Marathon, Mesos, Kubernetes, Consul, Etcd, Zookeeper, BoltDB, Rest API 等等后端模型。</p>
<p>traefik 的具体模型如下：<br><img src="https://github.com/containous/traefik/raw/master/docs/img/architecture.png" alt="traefik"></p>
<h2 id="为什么选择-traefik？"><a href="#为什么选择-traefik？" class="headerlink" title="为什么选择 traefik？"></a>为什么选择 traefik？</h2><p>事实上在之前我对 LB 的选择一直更倾向于使用 <a href="http://www.haproxy.org" target="_blank" rel="external">HAProxy</a>。但是选择 traefik 主要是有以下特点让我们决定使用：</p>
<ul>
<li>Golang 编写，单文件部署，与系统无关，同时也提供小尺寸 Docker 镜像。</li>
<li>支持 Docker/Etcd 后端，天然连接我们的微服务集群。</li>
<li>内置 Web UI，管理相对方便。</li>
<li>自动配置 ACME(Let’s Encrypt) 证书功能。</li>
<li>性能尚可，我们也没有到压榨 LB 性能的阶段，易用性更重要。</li>
</ul>
<p>除了这些以外，traefik 还有以下特点：</p>
<ul>
<li>Restful API 支持。</li>
<li>支持后端健康状态检查，根据状态自动配置。</li>
<li>支持动态加载配置文件和 graceful 重启。</li>
<li>支持 WebSocket 和 HTTP/2。</li>
</ul>
<p>除了上面提到的微服务化集群支持，一些 AB 测试阶段也可以通过 frontend 的路由特性进行动态分配，当然这些对 HAProxy 等软件都是标准支持的。</p>
<h2 id="traefik-的配置"><a href="#traefik-的配置" class="headerlink" title="traefik 的配置"></a>traefik 的配置</h2><p>traefik 支持的配置方式支持文件方式进行配置，这个也是比较常见的配置方式，我们这里简单介绍一下。</p>
<p>traefik 支持的 toml 方式进行配置，官方提供了一个 <a href="https://docs.traefik.io/toml/" target="_blank" rel="external">示例的 traefik.toml 文件</a> 用于演示配置。除此之外，后端服务一般是采用单独文件进行存储，比如演示配置中指定的 rules.toml。</p>
<p>具体一个例子，如果我们有两个后端，127.0.0.1:7727，127.0.0.1:7728，我们希望所有的 Chrome 用户都可以访问 127.0.0.1:7727，其它人都访问 127.0.0.1:7728，这样这个 rules.toml 应该如何配置呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rules.toml</span></div><div class="line"><span class="section">[backends]</span></div><div class="line"><span class="section">  [backends.backend1]</span></div><div class="line"><span class="section">    [backends.backend1.servers.server1]</span></div><div class="line">    url = "http://127.0.0.1:7727"</div><div class="line"><span class="section">  [backends.backend2]</span></div><div class="line"><span class="section">    [backends.backend2.servers.server1]</span></div><div class="line">    url = "http://127.0.0.1:7728"</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">[frontends]</span></div><div class="line"><span class="section">  [frontends.frontend1]</span></div><div class="line">  entrypoints = ["http"]</div><div class="line">  backend = "backend1"</div><div class="line"><span class="section">    [frontends.frontend1.routes.test_1]</span></div><div class="line">    rule = "HeadersRegexp: User-Agent, Chrome"</div><div class="line"><span class="section">  [frontends.frontend2]</span></div><div class="line">  entrypoints = ["http"]</div><div class="line">  backend = "backend2"</div></pre></td></tr></table></figure>
<p>首先定义两个后端服务，每个后端服务可以支持多个服务单元，这里我们只有一个。前端 frontends 用于匹配请求落到哪个后端服务中。我们这里定义一个规则 test_1，设置规则为根据 HTTP 请求头部正则进行分配：如果 UserAgent 中包含 Chrome 字样，则访问到 127.0.0.1:7727。匹配的规则方式包含了以下几种方式:</p>
<ul>
<li><code>Headers</code>/<code>HeaderRegexp</code>: 头部匹配方式，分别对应按值和正则表达式两种方式。</li>
<li><code>Host</code>/<code>HostRegexp</code>: 按照请求主机名进行匹配，与头部信息相似。</li>
<li><code>Method</code>: 按照请求方式区分。</li>
<li><code>Path</code>/<code>PathStrip</code>/<code>PathPrefix</code>/<code>PathPrefixStrip</code>: 按照路径区分后端。</li>
</ul>
<h2 id="traefik-与微服务集群"><a href="#traefik-与微服务集群" class="headerlink" title="traefik 与微服务集群"></a>traefik 与微服务集群</h2><p>这个有人已经写过相关的文章了，我在这里简单推荐一下： <a href="http://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/" target="_blank" rel="external">Microservices Bliss with Docker and Traefik</a>（<a href="http://dockone.io/article/1418" target="_blank" rel="external">中文译文</a>）。我就不做额外的描述了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ipfans.github.io/2016/07/type-hint-improve-python-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/type-hint-improve-python-programming/" itemprop="url">利用 Type Hint 提升 Python 程序开发效率</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-13T20:00:00+08:00">
                2016-07-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/07/type-hint-improve-python-programming/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/07/type-hint-improve-python-programming/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Type Hint（或者叫做 PEP-484）提供了一种针对 Python 程序的类型标注标准。</p>
<p>为什么使用 Type Hint？对于动态语言而言，常常出现的情况是当你写了一段代码后，隔段时间你可能忘记这个方法的原型是什么样子的了，你也不清楚具体应该传入什么类型的参数，这样往往需要你去阅读代码才能定义每个类型具体是什么。或者当你使用一个文档并不是特别完全的第三方库，你不知道这个库应该如何使用，这都会很痛苦。</p>
<p>现在，借助 Type Hint，你可以实现：</p>
<ul>
<li>实现类型检查，防止运行时出现的类型不符合情况。</li>
<li>作为文档附加属性，方便开发者调用时传入传出的参数类型。</li>
<li>提升 IDE 的检查机制，在智能提示时更快给出提示和类型检查结果。</li>
</ul>
<p>实现这个过程中，你需要使用 <figure class="highlight python"><figcaption><span>3.5+``` 中提供的新模块 [```typing```](https://docs.python.org/3.5/library/typing.html)。值得注意的是，这个改动并不会影响程序运行，仅仅是为了方便类型检查器实现的。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">## Type Hint 类型检查器</span></div><div class="line"></div><div class="line">目前，比如 ```JetBrains``` 家的 ```PyCharm``` 已经支持 Type Hint 语法检查功能，如果你使用了这个 IDE，可以通过 IDE 功能进行实现。如果你像我一样，使用了 SublimeText 编辑器，那么第三方工具 [```mypy```](https://github.com/python/mypy) 可以帮助到你。```AnacondaST3``` 最近要发布的 <span class="number">2.0</span> 版本也内置了 ```mypy``` 功能的支持，具体的进度可以看一下 [这个 issue](https://github.com/DamnWidget/anaconda/issues/<span class="number">439</span>)。一些其它的 Python 工具 (比如 [代码提示工具 jedi <span class="number">0.10</span>+](https://github.com/davidhalter/jedi/pull/<span class="number">661</span>)) 也支持了 Type Hint 功能。</div><div class="line"></div><div class="line"><span class="comment">## 从简单的例子开始</span></div><div class="line"></div><div class="line">从简单的例子开始，我们先从一个简单的程序开始，运行环境为 ```Python <span class="number">3.5</span><span class="number">.2</span>```，使用 ```mypy``` 工具进行检查。</div><div class="line"></div><div class="line">首先通过 ```pip install mypy-lang``` 命令安装 ```mypy``` 工具。注意是 ```mypy-lang```，之所以是这样，是因为在 ```pypi``` 里 ```mypy``` 这个名字已经被占用掉了。</div><div class="line"></div><div class="line">接下来，通过 ```mypy``` 检查下面这个文件</div><div class="line"></div><div class="line">```python</div><div class="line"><span class="comment"># fib.py</span></div><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n: int)</span> -&gt; Iterator[int]:</span></div><div class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> a &lt; n:</div><div class="line">        <span class="keyword">yield</span> a</div><div class="line">        a, b = b, a + b</div><div class="line"></div><div class="line">i = fib(<span class="number">3.2</span>)</div><div class="line">print(next(i))</div><div class="line">print(next(i))</div></pre></td></tr></table></figure></p>
<p>在命令行中执行命令 <figure class="highlight plain"><figcaption><span>fib.py```，获取返回结果：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>➜ mypy fib.py<br>fib.py:11: error: Argument 1 to “fib” has incompatible type “float”; expected “int”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是在实际的应用过程中，这个功能在 Python 里是可以正常运行的：</div></pre></td></tr></table></figure></p>
<p>➜  mypy python fib.py<br>0<br>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以看到，mypy 工具提示了我们的代码中存在一处类型不匹配的问题，但是如果不进行检查，代码有可能执行出不可预知的结果。</div><div class="line"></div><div class="line">在这个例子里面，我们使用了两种类型，一种是 Python 基础数据类型，比如 ```str```、```int``` 等等，这些类型数据是可以直接使用的；另外一种是来自于 ```typing``` 中引入的 ```Iterator```，用来表示迭代器类型。另外一个值得注意的是，```typing``` 中部分类型也会随时添加，一般我们以演示版本为准。</div><div class="line"></div><div class="line">从简单到复杂，类型组合怎么办？</div><div class="line">---</div><div class="line"></div><div class="line">实际上，在我们使用过程中还有可能传递一些更加复杂的参数类型，比如 list 类型，tuple 类型等等，这类型的数据如何声明呢？我们可以先看一个例子：</div><div class="line"></div><div class="line">```python</div><div class="line">def foo(strings, string_list, count, total):</div></pre></td></tr></table></figure></p>
<p>这个函数的参数我们从字面可以看出来分别是 <figure class="highlight plain"><figcaption><span>```str``` 的 ```list``` 类型和两个整数参数。我们假定一个返回值为 ```((int, int), str)```，那么这个类型检查可以这样定义：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```python</div><div class="line">from typing import List, Tuple</div><div class="line"></div><div class="line">Result = Tuple[Tuple[int, int], str]</div><div class="line"></div><div class="line">def foo(strings: str, lines: List[str],  line_number: int, total_lines: int) -&gt; Result:</div></pre></td></tr></table></figure></p>
<p>其它的一些类型提示、协程等等的支持都可以在官方的 <a href="https://docs.python.org/3.5/library/typing.html" target="_blank" rel="external"><code>typing</code> 模块文档</a> 中进行查看。</p>
<h2 id="关于生产的一些闲扯"><a href="#关于生产的一些闲扯" class="headerlink" title="关于生产的一些闲扯"></a>关于生产的一些闲扯</h2><p>我们现在也在进行一些 <code>mypy</code> 工具在生产环境中的具体使用测试，但是我们也发现了一些存在的问题，比如 <code>Python</code> 本身的动态语言特性给类型标注就带来了一些麻烦。另外，变量复用导致的类型变换有可能会提示采用新的变量实现。这对于一个已经存在的线上项目来说相对成本较高，我们后续也会在一些新项目中采用这种方式。另外 <code>mypy</code> 还是一个比较新的项目，本身是拥有一些 bug。另外一个是在某些 <code>mypy</code> 的非类型错误提示其实非常的模糊，导致很多错误有时需要进行人工排查。</p>
<p>不管怎样，即便在 <code>mypy</code> 存在一些缺陷，但是仍旧是未来非常有潜力的工具，提前了解和应用也能有效的提升程序的强壮性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ipfans.github.io/2016/05/learning-coreos-part3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/learning-coreos-part3/" itemprop="url">CoreOS 折腾笔记（三）了解 Etcd</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-31T09:13:00+08:00">
                2016-05-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/05/learning-coreos-part3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/05/learning-coreos-part3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>服务发现是微服务化架构中重要的一环，服务的配置信息需要有一种可靠高效的发现机制，保证服务上线时可以及时被使用，服务失效中断时可以及时切走。服务发现工具 Etcd 就是为了这种需求开发的。</p>
<h2 id="什么是-Etcd？"><a href="#什么是-Etcd？" class="headerlink" title="什么是 Etcd？"></a>什么是 Etcd？</h2><p>Etcd 是一个分布式 KV 数据库，通过将数据分散存储在多台独立的设备上，从而提高数据的可靠性或读写性能。Etcd 是几个比较常见的服务发现应用之一，它支持 TTL 的支持和 HTTP Restful API，同时通过 Raft 一致性算法处理日志复制以保证强一致性。关于 Raft 算法，请参考 <a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd" target="_blank" rel="external">这篇文章</a>，这里不多介绍。Etcd 本来就是 CoreOS 团队开发支持的，因此也是原生存在在 CoreOS 系统中。</p>
<p>Etcd 中提供了订阅通知机制，同时提供了一个线上服务 <figure class="highlight plain"><figcaption><span>Fleet 等等工具也是基于 Etcd 去发现网络中的节点服务器。在 CoreOS 机器部署之后，系统中一个叫做 ```cloud-init``` 的服务会根据之前的 ```user-data``` 文件去启动 Etcd。Etcd 会更新对应的自己的节点信息，并且获取其它的节点信息。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">另外比较常见的服务发现还有 ZooKeeper（应用最广泛）、Consul 等等，如果有兴趣，可以自己在进行研究。</div><div class="line"></div><div class="line">## Etcdctl 使用</div><div class="line"></div><div class="line">工具 ```etcdctl``` 是 ```etcd``` 的控制程序，我们可以通过执行命令查看所有键值：</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ etcdctl ls / –recursive<br>/coreos.com<br>/coreos.com/network<br>/coreos.com/network/config<br>/coreos.com/network/subnets<br>/coreos.com/network/subnets/10.1.64.0-24<br>/coreos.com/network/subnets/10.1.48.0-24<br>/coreos.com/network/subnets/10.1.10.0-24<br>/coreos.com/updateengine<br>/coreos.com/updateengine/rebootlock<br>/coreos.com/updateengine/rebootlock/semaphore<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">还可以通过类似 Redis 的 ```get``` 等命令获取具体存储内容：</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ etcdctl get /coreos.com/network/subnets/10.1.64.0-24<br>{“PublicIP”:”172.17.8.101”}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">区别是 Etcd 是支持目录的：</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ etcdctl mkdir hello<br>core@core-01 ~ $ etcdctl get hello<br>/hello: is a directory<br>core@core-01 ~ $ etcdctl rmdir hello<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">刚刚我们介绍时也提到，Etcd 支持 HTTP 方式调用，比如：</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ curl -L -X PUT <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="external">http://127.0.0.1:2379/v2/keys/message</a> -d value=”Hello”<br>{“action”:”set”,”node”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10318,”createdIndex”:10318},”prevNode”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10300,”createdIndex”:10300}}<br>core@core-01 ~ $ etcdctl get /message<br>Hello<br>core@core-01 ~ $ curl -L -X DELETE <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="external">http://127.0.0.1:2379/v2/keys/message</a><br>{“action”:”delete”,”node”:{“key”:”/message”,”modifiedIndex”:10462,”createdIndex”:10318},”prevNode”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10318,”createdIndex”:10318}}<br>core@core-01 ~ $ etcdctl get /message<br>Error:  100: Key not found (/message) [10467]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">TTL 的特性可以在设置状态时进行设定：</div></pre></td></tr></table></figure></p>
<p>etcdctl set /foo “Expiring Soon” –ttl 20<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个 KV 对就会在 20 秒内时效。</div><div class="line"></div><div class="line">## Etcd 集群管理</div><div class="line"></div><div class="line">除了本身的 KV 数据库特性外，作为集群服务发现工具时，也可以通过 restful api 方式发现当前集群信息：</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ curl -L <a href="http://127.0.0.1:4001/v2/stats/leader" target="_blank" rel="external">http://127.0.0.1:4001/v2/stats/leader</a><br>{“leader”:”efb737dfdc9ee528”,”followers”:{“6219cfe16536320”:{“latency”:{“current”:0.003561,”average”:0.0031178274017212987,”standardDeviation”:0.018016615756979302,”minimum”:9e-06,”maximum”:1.338917},”counts”:{“fail”:0,”success”:51588}},”a8cc28a8e121c40d”:{“latency”:{“current”:0.002212,”average”:0.002837358092138387,”standardDeviation”:0.015615452604769925,”minimum”:1.7e-05,”maximum”:1.48721},”counts”:{“fail”:0,”success”:51618}},”e44ee28dd4e590ac”:{“latency”:{“current”:0.001838,”average”:0.006247004906804689,”standardDeviation”:0.4458222893241591,”minimum”:9e-06,”maximum”:105.637627},”counts”:{“fail”:32,”success”:58694}}}}<br>core@core-01 ~ $ curl -L <a href="http://127.0.0.1:4001/v2/stats/self" target="_blank" rel="external">http://127.0.0.1:4001/v2/stats/self</a><br>{“name”:”c99fef8aac9b4a3e9d3a44f58b0739a6”,”id”:”efb737dfdc9ee528”,”state”:”StateLeader”,”startTime”:”2016-05-28T09:44:01.416629553Z”,”leaderInfo”:{“leader”:”efb737dfdc9ee528”,”uptime”:”1h59m14.023315023s”,”startTime”:”2016-05-28T09:44:44.495996231Z”},”recvAppendRequestCnt”:0,”sendAppendRequestCnt”:162816,”sendPkgRate”:20.004570208101516,”sendBandwidthRate”:1953.7463493742348}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其它的系列集群接口，也可以在 [官方文档](https://coreos.com/etcd/docs/latest/) 中查看。</div><div class="line"></div><div class="line">## Etcd 配置</div><div class="line"></div><div class="line">如果你有印象在第一篇中，如果你打开 ```user-data``` 文件，你就会发现 Etcd 的踪影：</div><div class="line"></div><div class="line">```yaml</div><div class="line">➜  coreos-vagrant git:(master) cat user-data</div><div class="line">#cloud-config</div><div class="line"></div><div class="line">---</div><div class="line">coreos:</div><div class="line">  etcd2:</div><div class="line">    advertise-client-urls: http://$public_ipv4:2379</div><div class="line">    initial-advertise-peer-urls: http://$private_ipv4:2380</div><div class="line">    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001</div><div class="line">    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001</div><div class="line">    discovery: https://discovery.etcd.io/xxxxxxxxxxxx</div><div class="line">  fleet:</div><div class="line">    public-ip: &quot;$public_ipv4&quot;</div><div class="line">  flannel:</div><div class="line">    interface: &quot;$public_ipv4&quot;</div><div class="line">....</div></pre></td></tr></table></figure></p>
<p>我们这里使用了线上服务 <code>https://discovery.etcd.io/</code> 发现集群中的机器，这个服务同样也可以使用本地内系统。</p>
<h2 id="利用-Etcd-制作服务发现"><a href="#利用-Etcd-制作服务发现" class="headerlink" title="利用 Etcd 制作服务发现"></a>利用 Etcd 制作服务发现</h2><p>之前提到，Etcd 的特性非常方便用做服务发现，具体如何操作呢？在谈具体实现之前，我们来介绍一下两种服务注册方法：一种叫做 <a href="http://microservices.io/patterns/self-registration.html" target="_blank" rel="external">自注册方法</a>；另外一种叫 <a href="http://microservices.io/patterns/3rd-party-registration.html" target="_blank" rel="external">第三方注册方法</a>。区别是是否由自身来进行健康检查和提醒。另外，服务发现重要的是，在服务失效时可以及时去除无效服务，这个在 Etcd 的 TTL 功能上就会显得比较重要。我们可以设置一个键值的有效期为 3 秒，并且每秒钟都来刷新授权，如果程序异常退出或者刷新不及时，那么这个服务简直就会失效。通过这种方式就可以有效验证服务是否有效。</p>
<p>具体的代码就不再额外给出了，大家可以自己动手实现一下。另外，其实服务发现还有一个重要的是提供自身工作的地址端口信息，这些可以通过环境变量传递到容器的注册过程中去，这个也是能够让负载均衡或者 WebService 服务器可以识别服务的重要手段。比如 Nginx 可以在根据服务注册信息定期更新自己的配置文件，利用重载保证不间断的服务运行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ipfans.github.io/2016/05/learning-coreos-part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/learning-coreos-part2/" itemprop="url">CoreOS 折腾笔记（二）Fleet 进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-28T18:00:00+08:00">
                2016-05-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/05/learning-coreos-part2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/05/learning-coreos-part2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果要说什么样子的分布式集群对用户是最友好的，那无疑是对客户来说，像本地执行命令一样方便的执行集群命令肯定是最舒服的了。这个我们在上一节 <a href="http://ipfans.github.io/2016/05/learning-coreos-part1/">集群部署</a> 里面就提到了一个叫做 “fleetctl” 的命令，这个命令是做什么用的呢？</p>
<h2 id="fleet-是什么"><a href="#fleet-是什么" class="headerlink" title="fleet 是什么"></a>fleet 是什么</h2><p>工具 <figure class="highlight plain"><figcaption><span>是一个在集群层面上的 ```systemd``` 管理工具。它的配置文件语法基于 ```systemd``` 的语法，另外添加了一些自有的属性。如果你希望在集群中运行你的服务，那么使用 ```fleet``` 管理 ```systemd``` 单元是再有必要不过的了。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在比较新的系统 (CentOS 7+、Ubuntu 16+、Debian 8+) 中均采用了 ```systemd``` 作为启动项管理工具。如果你对 ```systemd``` 有疑问的话，请到其 [官方网站](https://www.freedesktop.org/wiki/Software/systemd/) 查看具体的介绍，这里不做赘述。</div><div class="line"></div><div class="line">之前使用的 ```fleetctl``` 就是 ```fleet``` 的管理工具，默认是在集群中的某台机器上进行管理。当然，```fleetctl``` 同样也可以通过远程进行管理，可以通过如下命令连接远程集群。</div></pre></td></tr></table></figure></p>
<p>FLEETCTL_ENDPOINT=http://<ip:[port]> fleetctl list-units<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## fleetctl 常见命令</div><div class="line"></div><div class="line">比较常见的 ```fleetctl``` 命令有：</div></pre></td></tr></table></figure></ip:[port]></p>
<p>core@core-01 ~ $ fleetctl -h<br>…<br>COMMANDS:<br>    cat                查看已经提交的单元文件内容<br>    destroy            销毁集群中的一个或多个单元<br>    fd-forward        将标准输入输出转向到一个 unix socket 中<br>    journal            将集群中的某个 unit 的日志输出到当前<br>    list-machines    查看集群中的已知机器<br>    list-unit-files    查看集群中存在的单元<br>    list-units        查看集群中的单元状态<br>    load            将一个或多个单元加载到集群中，必要时会先执行 submit 功能<br>    ssh                连接到集群中的某台机器<br>    start            启动集群中一个或多个单元，必要时会先执行 submit 和 load 功能<br>    status            输出集群中一个或多个单元的状态<br>    stop            停止集群中一个或多个单元<br>    submit            上传一个或多个单元到集群中，并不会加载执行<br>    unload            卸载集群中的一个或多个单元<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## fleet 单元文件</div><div class="line"></div><div class="line">以一个 ```Hello World``` 程序作为演示来讲解：</div><div class="line"></div><div class="line">```ini</div><div class="line">[Unit]</div><div class="line">Description=Echo Hello World</div><div class="line">After=docker.service</div><div class="line">Requires=docker.service</div><div class="line"></div><div class="line">[Service]</div><div class="line">TimeoutStartSec=0</div><div class="line">ExecStartPre=-/usr/bin/docker kill busybox</div><div class="line">ExecStartPre=-/usr/bin/docker rm busybox</div><div class="line">ExecStartPre=/usr/bin/docker pull busybox</div><div class="line">ExecStart=/usr/bin/docker run --name busybox busybox /bin/sh -c &quot;trap&apos;exit 0&apos;INT TERM; while true; do echo Hello World; sleep 1; done&quot;</div><div class="line">ExecStop=/usr/bin/docker stop busybox</div></pre></td></tr></table></figure></p>
<p>看起来基本与 <figure class="highlight plain"><figcaption><span>语法一致。保存成 ```helloworld.service```，然后执行命令：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl start helloworld.service<br>Unit helloworld.service inactive<br>Unit helloworld.service launched on 6e1b9fae…/172.17.8.104<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以通过 ```fleetctl``` 查看状态：</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl list-units<br>UNIT            MACHINE                ACTIVE    SUB<br>helloworld.service    6e1b9fae…/172.17.8.104    active    running<br>core@core-01 ~ $ fleetctl list-unit-files<br>UNIT            HASH    DSTATE        STATE        TARGET<br>helloworld.service    ce68bd4    launched    launched    6e1b9fae…/172.17.8.104<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同时，可以通过 ```fleetctl journal``` 查看程序是否正常运行了。</div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl journal helloworld<br>The authenticity of host ‘172.17.8.104’ can’t be established.<br>ECDSA key fingerprint is 11:63:ee:93:e4:b9:5e:06:e9:c6:cd:63:e2:df:ef:9e.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘172.17.8.104’ (ECDSA) to the list of known hosts.<br>– Logs begin at Sat 2016-05-28 08:45:39 UTC, end at Sat 2016-05-28 10:09:13 UTC. –<br>May 28 10:09:04 core-04 docker[1163]: Hello World<br>May 28 10:09:05 core-04 docker[1163]: Hello World<br>May 28 10:09:06 core-04 docker[1163]: Hello World<br>May 28 10:09:07 core-04 docker[1163]: Hello World<br>May 28 10:09:08 core-04 docker[1163]: Hello World<br>May 28 10:09:09 core-04 docker[1163]: Hello World<br>May 28 10:09:10 core-04 docker[1163]: Hello World<br>May 28 10:09:11 core-04 docker[1163]: Hello World<br>May 28 10:09:12 core-04 docker[1163]: Hello World<br>May 28 10:09:13 core-04 docker[1163]: Hello World<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 通过 fleet 单元文件实现高可用服务</div><div class="line"></div><div class="line">实现高可用服务需要多个服务实例：当其中一个服务实例出现问题时，不会干扰其它服务实例的运行。这里我们还是使用上一节中提到的单元文件，但是需要做额外的修改让其支持多实例运行：</div><div class="line"></div><div class="line">```ini</div><div class="line">[Unit]</div><div class="line">Description=Echo Hello World</div><div class="line">After=docker.service</div><div class="line">Requires=docker.service</div><div class="line"></div><div class="line">[Service]</div><div class="line">TimeoutStartSec=0</div><div class="line">ExecStartPre=-/usr/bin/docker kill busybox</div><div class="line">ExecStartPre=-/usr/bin/docker rm busybox</div><div class="line">ExecStartPre=/usr/bin/docker pull busybox</div><div class="line">ExecStart=/usr/bin/docker run --name busybox busybox /bin/sh -c &quot;trap&apos;exit 0&apos;INT TERM; while true; do echo Hello World; sleep 1; done&quot;</div><div class="line">ExecStop=/usr/bin/docker stop busybox</div><div class="line"></div><div class="line">[X-Fleet]</div><div class="line">Conflicts=helloworld@*.service</div></pre></td></tr></table></figure></p>
<p>最后新增的内容是 fleet 的专属语法，使用 <figure class="highlight plain"><figcaption><span>可以限定每台机器上仅允许一个 ```helloworld``` 服务运行。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl stop helloworld<br>Unit helloworld.service loaded on 6e1b9fae…/172.17.8.104<br>core@core-01 ~ $ fleetctl unload helloworld<br>Unit helloworld.service inactive<br>core@core-01 ~ $ mv helloworld.service helloworld@.service<br>core@core-01 ~ $ fleetctl start helloworld@1<br>Unit helloworld@1.service inactive<br>Unit helloworld@1.service launched on 6e1b9fae…/172.17.8.104<br>core@core-01 ~ $ fleetctl start helloworld@2<br>Unit helloworld@2.service inactive<br>Unit helloworld@2.service launched on 91060182…/172.17.8.103<br>core@core-01 ~ $ fleetctl start helloworld@3<br>Unit helloworld@3.service inactive<br>Unit helloworld@3.service launched on af1494a6…/172.17.8.102<br>core@core-01 ~ $ fleetctl start helloworld@4<br>Unit helloworld@4.service inactive<br>Unit helloworld@4.service launched on c99fef8a…/172.17.8.101<br>core@core-01 ~ $ fleetctl list-unit-files<br>UNIT            HASH    DSTATE        STATE        TARGET<br>helloworld.service    ce68bd4    inactive    inactive    -<br>helloworld@1.service    ce68bd4    launched    launched    6e1b9fae…/172.17.8.104<br>helloworld@2.service    ce68bd4    launched    launched    91060182…/172.17.8.103<br>helloworld@3.service    ce68bd4    launched    launched    af1494a6…/172.17.8.102<br>helloworld@4.service    ce68bd4    launched    launched    c99fef8a…/172.17.8.101<br>```</p>
<p>卸载之前的 <code>helloworld</code>，执行了新的 4 个实例，通过观察可以看到目前实例都是运行在了 4 台不同机器上。</p>
<h1 id="fleet-的一些疑问"><a href="#fleet-的一些疑问" class="headerlink" title="fleet 的一些疑问"></a>fleet 的一些疑问</h1><p>事实上，通过 fleet，可以将服务进行多副本部署，同时通过 fleet 守护程序的正常运行。但是在实际使用中你会发现有一个实际问题，在微服务化场景中，每个服务部署的机器是无法控制的，那么我们怎么知道服务究竟在哪呢？</p>
<p>如何控制流量流向，或者说服务发现问题，这个我会在下一个 <code>Etcd</code> 的介绍中说一下，敬请期待。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/363344?v=3&s=460"
               alt="ipfans" />
          <p class="site-author-name" itemprop="name">ipfans</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ipfans" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/janxin" target="_blank" title="Tw1tter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Tw1tter
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.yeeuu.com" title="杭州云柚科技" target="_blank">杭州云柚科技</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ipfans</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://s1mbily.disqus.com/count.js" async></script>
    

    

  




	





  








  





  

  

  

  

  

  

</body>
</html>
