<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Python,async,PEPs," />





  <link rel="alternate" href="/atom.xml" title="ipfans's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="原文地址: PEP-0492    PEP 492     标题 协程与 async/await 语法   作者 Yury Selivanov at magic.io&amp;gt;```|1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606">
<meta name="keywords" content="Python,async,PEPs">
<meta property="og:type" content="article">
<meta property="og:title" content="PEP 0492 Coroutines with async and await syntax 中文翻译">
<meta property="og:url" content="https://ipfans.github.io/2015/10/coroutines-with-async-and-await-syntax-chinese/index.html">
<meta property="og:site_name" content="ipfans&#39;s Blog">
<meta property="og:description" content="原文地址: PEP-0492    PEP 492     标题 协程与 async/await 语法   作者 Yury Selivanov at magic.io&amp;gt;```|1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-02T10:33:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PEP 0492 Coroutines with async and await syntax 中文翻译">
<meta name="twitter:description" content="原文地址: PEP-0492    PEP 492     标题 协程与 async/await 语法   作者 Yury Selivanov at magic.io&amp;gt;```|1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ipfans.github.io/2015/10/coroutines-with-async-and-await-syntax-chinese/"/>





  <title>PEP 0492 Coroutines with async and await syntax 中文翻译 | ipfans's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b9862358b198078f40d7e1596b7c5968";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ipfans's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ipfans.github.io/2015/10/coroutines-with-async-and-await-syntax-chinese/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">PEP 0492 Coroutines with async and await syntax 中文翻译</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-31T12:48:15+08:00">
                2015-10-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/10/coroutines-with-async-and-await-syntax-chinese/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/10/coroutines-with-async-and-await-syntax-chinese/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文地址: <a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="external">PEP-0492</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">PEP</th>
<th style="text-align:left">492</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标题</td>
<td style="text-align:left">协程与 async/await 语法</td>
</tr>
<tr>
<td style="text-align:left">作者</td>
<td style="text-align:left">Yury Selivanov <figure class="highlight plain"><figcaption><span>at magic.io>```|</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">| 翻译 | ipfans ```&lt;ipfanscn at gmail.com&gt;```|</div><div class="line">| 状态 | 最终稿 |</div><div class="line">|Python 版本 | 3.5|</div><div class="line">| 翻译最后更新 | 2015-11-03|</div><div class="line"></div><div class="line"></div><div class="line">目录</div><div class="line"></div><div class="line">[摘要](#Abstract)    </div><div class="line">[API 设计和实现的备注](#API-Design-and-Implementation-Note)    </div><div class="line">[基本原理和目标](#Rationale-and-Goals)   </div><div class="line">[语法规范](#Specification)</div><div class="line"></div><div class="line">   * [新协程声明语法](#New-Coroutine-Declaration-Syntax)</div><div class="line">   * [types.coroutine()](#Type-Coroutine)</div><div class="line">   * [Await 表达式](#Await-Expression)</div><div class="line">     * [新的操作符优先级列表](#Updated-operator-precedence-table)</div><div class="line">     * [await 表达式示例](#Examples-of-await-expressions)</div><div class="line">   * [异步上下文管理与 ```async with```](#Asynchronous-Context-Managers)</div><div class="line">      * [新语法](#Async-With-New-Syntax)</div><div class="line">      * [例子](#Async-With-Example)</div><div class="line">   * [异步迭代器与 ```async for```](#Asynchronous-Iterators)</div><div class="line">      * [新语法](#Async-For-New-Syntax)</div><div class="line">      * [例子 1](#Async-For-Example-1)</div><div class="line">      * [例子 2](#Async-For-Example-2)</div><div class="line">      * [为什么使用 ```StopAsyncIteration```](#Why-StopAsyncIteration)</div><div class="line">   * [协程对象](#Coroutine-objects)</div><div class="line">     * [与生成器的不同之处](#Differences-from-generators)</div><div class="line">     * [协程对象方法](#Coroutine-object-methods)</div><div class="line">   * [调试特性](#Debugging-Features)</div><div class="line">   * [新的标准库函数](#New-Standard-Library-Functions)</div><div class="line">   * [新的抽象基类](#New-Abstract-Base-Classes)</div><div class="line"></div><div class="line">[专用术语表](#Glossary)   </div><div class="line">[函数与方法列表](#List-of-functions-and-methods)   </div><div class="line">[移植计划](#Transition-Plan)</div><div class="line"></div><div class="line">   * [向后兼容性](#Backwards-Compatibility)</div><div class="line">     * [asyncio](#asyncio)</div><div class="line">     * [asyncio 移植策略](#asyncio-migration-strategy)</div><div class="line">     * [CPython 代码中的 ```async/await```](#async-await-in-CPython-code-base)</div><div class="line">   * [语法更新](#Grammar-Updates)</div><div class="line">   * [失效计划](#Deprecation-Plans)</div><div class="line"></div><div class="line">设计思路 (暂时不考虑翻译)   </div><div class="line">[性能](#Performance)</div><div class="line"></div><div class="line">   * [总体影响](#Overall-Impact)</div><div class="line">   * [编译器修改](#Tokenizer-modifications)</div><div class="line">   * [```async/await```](#async-await)</div><div class="line"></div><div class="line">[实现参考](#Reference-Implementation)</div><div class="line"></div><div class="line">   * [上层修改和新协议列表](#List-of-high-level-changes-and-new-protocols)</div><div class="line">   * [可以工作的实例](#working-example)</div><div class="line"></div><div class="line">参考</div><div class="line"></div><div class="line">致谢</div><div class="line"></div><div class="line">版权信息</div><div class="line"></div><div class="line">## &lt;a name=&quot;Abstract&quot;&gt;&lt;/a&gt; 摘要</div><div class="line"></div><div class="line">不断增长的网络连通性需求带动了对响应性、伸缩性代码的需求。这个 PEP 的目标在于回答如何更简单的、Pythinic 的实现显式的异步 / 并发的 Python 代码。</div><div class="line"></div><div class="line">我们把协程概念独立出来，并为其使用新的语法。最终目标是建立一个通用、易学的 Python 异步编程模型，并尽量与同步编程的风格保持一致。</div><div class="line"></div><div class="line">这个 PEP 假设异步任务被一个事件循环器（类似于标准库里的 asyncio.events.AbstractEventLoop）管理和调度。不过，我们并不会依赖某个事件循环器的具体实现方法，从本质上说只与此相关：使用 yield 作为给调度器的信号，表示协程将会挂起直到一个异步事件（如 IO）完成。</div><div class="line"></div><div class="line">我们相信这些改变将会使 Python 在这个异步编程快速增长的领域能够保持一定的竞争性，就像许多其它编程语言已经、将要进行的改变那样。</div><div class="line"></div><div class="line">## &lt;a name=&quot;API-Design-and-Implementation-Note&quot;&gt;&lt;/a&gt;API 设计和实现的备注</div><div class="line"></div><div class="line">根据 Python 3.5 Beta 期间的反馈，我们进行了重新设计：明确的把协程从生成器里独立出来 --- 原生协程现在拥有了自己完整的独立类型，而不再是一种新的生成器类型。</div><div class="line"></div><div class="line">这个改变主要是为了解决在 Tornado Web 服务中里集成协程时出现的一些问题。</div><div class="line"></div><div class="line">## &lt;a name=&quot;Rationale-and-Goals&quot;&gt;&lt;/a&gt; 基本原理和目标</div><div class="line"></div><div class="line">现在版本的 Python 支持使用生成器实现协程功能 ([PEP-342](https://www.python.org/dev/peps/pep-0342))，后面通过 [PEP-380](https://www.python.org/dev/peps/pep-0380) 引入了 ```yield from``` 语法进行了增强。但是这样仍有一些缺点：</div><div class="line"></div><div class="line">   * 协程与常规的生成器在相同语法时用以混淆，尤其是对心开发者而言。</div><div class="line">   * 一个函数是否是协程需要通过是否主体代码中使用了 ```yield``` 或者 ```yield from``` 语句进行检测，这样在重构代码中添加、去除过程中容易出现不明显的错误</div><div class="line">   * 异步调用的支持被 ```yield``` 支持的语法先定了，导致我们无法使用更多的语法特性，比如 ```with``` 和 ```for``` 语句。</div><div class="line"></div><div class="line">这个提议的目的是将协程作为原生 Python 语言特性，并且将他们与生成器明确的区分开。它避免了生成器 / 协程中间的混淆请困高，方便编写出不依赖于特定库的协程代码。这个也方便 linter 和 IDE 能够实现更好的进行静态代码分析和重构。</div><div class="line"></div><div class="line">原生协程和相关的新语法特性使得可以在异步框架下可以定义一个上下文管理器和迭代协议。在这个提议后续中，新的 ```async with``` 语法让 Python 程序在进入和离开运行上下文时实现异步调用，新的 ```async for``` 语法可以在迭代器中实现异步调用。</div><div class="line"></div><div class="line">## &lt;a name=&quot;Specification&quot;&gt;&lt;/a&gt; 语法规范</div><div class="line"></div><div class="line">这个提议介绍了新的语法用于增强 Python 中的协程支持。</div><div class="line"></div><div class="line">这个语法规范假设你已经了解 Python 现有协程实现方法 ([PEP-342](https://www.python.org/dev/peps/pep-0342) 和 [PEP-380](https://www.python.org/dev/peps/pep-0380))。这次语法改变的动机来自于 asyncio 框架 ([PEP-3156](https://www.python.org/dev/peps/pep-3156)) 和 ```Cofunctions``` 提议 ([PEP-3152](https://www.python.org/dev/peps/pep-3152)，现在此提议已被废弃)。</div><div class="line"></div><div class="line">从本文档中，我们使用 ``` 原生协程 ``` 代指新语法生命的函数，``` 基于生成器的协程 ``` 用于表示那些基于生成器语法实现的协程。``` 协程 ``` 则表示两个地方都可以使用的内容。</div><div class="line"></div><div class="line"></div><div class="line">### &lt;a name=&quot;New-Coroutine-Declaration-Syntax&quot;&gt;&lt;/a&gt; 新协程声明语法</div><div class="line"></div><div class="line">下面的新语法用于声明原生协程：</div><div class="line"></div><div class="line">```python</div><div class="line">async def read_data(db):</div><div class="line">    pass</div></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<p>协程的主要属性包括：</p>
<ul>
<li><figure class="highlight plain"><figcaption><span>def``` 函数始终为协程，即使它不包含 ```await``` 表达式。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   * 如果在 ```async``` 函数中使用 ```yield``` 或者 ```yield from``` 表达式会产生 ```SyntaxError``` 错误。</div><div class="line">   * 在内部，引入了两个新的代码对象标记：</div><div class="line">      * ```CO_COROUTINE``` 用于标记原生协程（和新语法一起定义）</div><div class="line">      * ```CO_ITERABLE_COROUTINE``` 用于标记基于生成器的协程，兼容原生协程。(通过 ```types.coroutine()``` 函数设置)</div><div class="line">   * 常规生成器在调用时会返回一个 ```genertor``` 对象，同理，协程在调用时会返回一个 ```coroutine``` 对象。</div><div class="line">   * 协程不再抛出 ```StopIteration``` 异常，而是替代为 ```RuntimeError```。常规生成器实现类似的行为需要进行引入 ``` __future__```([PEP-3156](https://www.python.org/dev/peps/pep-3156))</div><div class="line">   * 当协程进行垃圾回收时，一个从未被 ```await``` 的协程会抛出 ```RuntimeWarning``` 异常。(参考 [调试特性](#Debugging-Features))</div><div class="line">   * 更多内容请参考 [协程对象](#Coroutine-objects) 一节。</div><div class="line"></div><div class="line">### &lt;a name=&quot;Type-Coroutine&quot;&gt;&lt;/a&gt;types.coroutine()</div><div class="line"></div><div class="line">在 ```types``` 模块中新添加了一个函数 ```coroutine(fn)``` 用于 ```asyncio``` 中基于生成器的协程与本 PEP 中引入的原生携协程互通。</div><div class="line"></div><div class="line">```python</div><div class="line">@types.coroutine</div><div class="line">def process_data(db):</div><div class="line">    data = yield from read_data(db)</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数将生成器函数对象设置 <figure class="highlight plain"><figcaption><span>标记，将返回对象变为 ```coroutine``` 对象。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果 ```fn``` 不是一个生成器函数，那么它会对其进行封装。如果它返回一个生成器，那么它会封装一个 ```awaitable``` 代理对象 (参考下面 ```awaitable``` 对象的定义)。</div><div class="line"></div><div class="line">注意：```CO_COROUTINE``` 标记不能通过 ```types.coroutine()``` 进行设置，这就可以将新语法定义的原生协程与基于生成器的协程进行区分。</div><div class="line"></div><div class="line">types 模块添加了一个新函数 coroutine(fn)，使用它，“生成器实现的协程” 和 “原生协程” 之间可以进行互操作。</div><div class="line"></div><div class="line">### &lt;a name=&quot;Await-Expression&quot;&gt;&lt;/a&gt;Await 表达式</div><div class="line"></div><div class="line">下面新的 ```await``` 表达式用于获取协程执行结果：</div><div class="line"></div><div class="line">```python</div><div class="line">async def read_data(db):</div><div class="line">    data = await db.fetch(&apos;SELECT ...&apos;)</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>与 ```yield from``` 相似，挂起 ```read_data``` 协程的执行直到 ```db.fetch``` 这个 ```awaitable``` 对象完成并返回结果数据。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">它复用了 ```yield from``` 的实现，并且添加了额外的验证参数。```await``` 只接受以下之一的 ```awaitable``` 对象：</div><div class="line"></div><div class="line">* 一个原生协程函数返回的原生协程对象。</div><div class="line">* 一个使用 ```types.coroutine()``` 修饰器的函数返回的基于生成器的协程对象。</div><div class="line">* 一个包含返回迭代器的 ```__await__``` 方法的对象。   </div><div class="line">   任意一个 ```yield from``` 链都会以一个 ```yield``` 结束，这是 ```Future``` 实现的基本机制。因此，协程在内部中是一种特殊的生成器。每个 ```await``` 最终会被 ```await``` 调用链条上的某个 ```yield``` 语句挂起（参考 [PEP-3156](https://www.python.org/dev/peps/pep-3156) 中的进一步解释）。   </div><div class="line">   为了启用协程的这一特点，一个新的魔术方法 ```__await__``` 被添加进来。在 ```asyncio``` 中，对于对象在 await 语句启用 ```Future``` 对象只需要添加 ```__await__ = __iter__``` 这行到 ```asyncio.Future``` 类中。   </div><div class="line">   在本 PEP 中，带有 ```__await__``` 方法的对象也叫做 ```Future-like``` 对象。</div><div class="line">   同样的，请注意到 ```__aiter__``` 方法（下面会定义）不能用于这种目的。它是不同的协议，有点类似于用 ```__iter__``` 替代普通调用方法的 ```__call___```。   </div><div class="line">   如果 ```__await__``` 返回非迭代器类型数据，会产生一个 ```TypeError```.</div><div class="line">* CPython C API 中使用 ``` tp_as_async.am_await``` 定义的函数，并且返回一个迭代器（类似 ```__await__``` 方法）。</div><div class="line"></div><div class="line">#### &lt;a name=&quot;Updated-operator-precedence-table&quot;&gt;&lt;/a&gt; 新的操作符优先级列表</div><div class="line"></div><div class="line">关键词 ```await``` 与 ```yield``` 和 ```yield form``` 操作符的区别是 ```await``` 表达式大部分情况下不需要括号包裹。</div><div class="line"></div><div class="line">同样的，```yield from``` 允许允许任意表达式做其参数，包含表达式如 ```yield a()+b()```，这样通常处理作为 ```yield from (a()+b())```，这个通常会造成 Bug。通常情况下任意算数操作的结果都不会是 ```awaitable``` 对象。为了避免这种情况，我们将 await 的优先级调整为低于 ```[], () 和.```，但是高于 ``` ** ``` 操作符。</div><div class="line"></div><div class="line">| 操作符 | 描述 |</div><div class="line">|:---|:----|</div><div class="line">|yield x , yield from x |Yield 表达式 |</div><div class="line">|lambda|Lambda 表达式 |</div><div class="line">|if -- else | 条件表达式 |</div><div class="line">|or | 布尔或 |</div><div class="line">|and | 布尔与 |</div><div class="line">|not x | 布尔非 |</div><div class="line">|in , not in , is , is not , &lt;, &lt;= ,&gt; , &gt;= , != , ==| 比较，包含成员测试和类型测试 |</div><div class="line">|\|| 字节或 |</div><div class="line">|^| 字节异或 |</div><div class="line">|&amp;| 字节与 |</div><div class="line">|&lt;&lt;,&gt;&gt;| 移位 |</div><div class="line">|+ , -  | 加和减 |</div><div class="line">|* , @ , / , // , %| 乘，矩阵乘法，除，取余 |</div><div class="line">|+x , -x , ~x | 正数, 复数, 取反 |</div><div class="line">|** | 平方 |</div><div class="line">|await x    |Await 表达式 |</div><div class="line">|x[index] , x[index:index] , x(arguments...) , x.attribute | 子集，切片，调用，属性 |</div><div class="line">|(expressions...) , [expressions...] , &#123;key: value...&#125; , &#123;expressions...&#125;| 类型显示 |</div><div class="line"></div><div class="line">#### &lt;a name=&quot;Examples-of-await-expressions&quot;&gt;&lt;/a&gt;await 表达式示例</div><div class="line"></div><div class="line">有效的语法例子:</div><div class="line"></div><div class="line">| 表达式 | 会被处理为 |</div><div class="line">|:---|:---|</div><div class="line">|if await fut: pass |if (await fut): pass|</div><div class="line">|if await fut + 1: pass |if (await fut) + 1: pass|</div><div class="line">|pair = await fut, &apos;spam&apos;|  pair = (await fut), &apos;spam&apos;|</div><div class="line">|with await fut, open(): pass|with (await fut), open(): pass|</div><div class="line">|await foo()[&apos;spam&apos;].baz()()    |await (foo()[&apos;spam&apos;].baz()() )|</div><div class="line">|return await coro()|   return ( await coro() )|</div><div class="line">|res = await coro() ** 2    |res = (await coro()) ** 2|</div><div class="line">|func(a1=await coro(), a2=0)|   func(a1=(await coro()), a2=0)|</div><div class="line">|await foo() + await bar()  |(await foo()) + (await bar())|</div><div class="line">|-await foo()|  -(await foo())|</div><div class="line"></div><div class="line">错误的语法例子:</div><div class="line"></div><div class="line">| 表达式 | 应写作 |</div><div class="line">|:---|:---|</div><div class="line">|await await coro()|    await (await coro())|</div><div class="line">|await -coro()| await (-coro())|</div><div class="line"></div><div class="line">### &lt;a name=&quot;Asynchronous-Context-Managers&quot;&gt;&lt;/a&gt; 异步上下文管理与 ```async with</div></pre></td></tr></table></figure>
<p>一个异步上下文管理器是用于在 <figure class="highlight plain"><figcaption><span>和 ```exit``` 方法中管理暂停执行的上下文管理器。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">为此，我们设置了新的异步上下文管理器。添加了两个魔术方法： ```__aenter__``` 和 ```__aexit__```。这两个方法都返回 ```awaitable``` 对象。</div><div class="line"></div><div class="line">异步上下文管理器例子如下：</div><div class="line"></div><div class="line">```python</div><div class="line">class AsyncContextManager:</div><div class="line">    async def __aenter__(self):</div><div class="line">        await log(&apos;entering context&apos;)</div><div class="line"></div><div class="line">    async def __aexit__(self, exc_type, exc, tb):</div><div class="line">        await log(&apos;exiting context&apos;)</div></pre></td></tr></table></figure></p>
<h4 id="新语法"><a href="#新语法" class="headerlink" title=" 新语法"></a><a name="Async-With-New-Syntax"></a> 新语法</h4><p>一个新的异步上下文管理语法被接受：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</div><div class="line">    BLOCK</div></pre></td></tr></table></figure>
<p>语义上等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mgr = (EXPR)</div><div class="line">aexit = type(mgr).__aexit__</div><div class="line">aenter = type(mgr).__aenter__(mgr)</div><div class="line">exc = <span class="keyword">True</span></div><div class="line"></div><div class="line">VAR = <span class="keyword">await</span> aenter</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    BLOCK</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">await</span> aexit(mgr, *sys.exc_info()):</div><div class="line">        <span class="keyword">raise</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">await</span> aexit(mgr, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<p>和普通的 <figure class="highlight plain"><figcaption><span>语句一样，可以在单个 ```async with``` 语句里指定多个上下文管理器。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在使用 ```async with``` 时，如果上下文管理器没有 ```__aenter__``` 和 ```__aexit__``` 方法，则会引发错误。在 ```async def``` 函数之外使用 ```async with``` 则会引发 ```SyntaxError``` 异常。</div><div class="line"></div><div class="line">#### &lt;a name=&quot;Async-With-Example&quot;&gt;&lt;/a&gt; 例子</div><div class="line"></div><div class="line">通过异步上下文管理器更容易实现协程对数据库事务的正确管理：</div><div class="line"></div><div class="line">```python</div><div class="line">async def commit(session, data):</div><div class="line">    ...</div><div class="line"></div><div class="line">    async with session.transaction():</div><div class="line">        ...</div><div class="line">        await session.update(data)</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>代码看起来也更加简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="keyword">with</span> lock:</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> lock):</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h3 id="异步迭代器与"><a href="#异步迭代器与" class="headerlink" title=" 异步迭代器与 "></a><a name="Asynchronous-Iterators"></a> 异步迭代器与 <figure class="highlight plain"><figcaption><span>for```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">一个异步迭代器能够在它的迭代实现里调用异步代码，也可以在它的 ```__next__``` 方法里调用异步代码。为了支持异步迭代，需要：</div><div class="line"></div><div class="line">1. 一个对象必须实现 ```__aiter__``` 方法（或者，使用 CPython C API 的 tp\_as\_async.am\_aiter 定义），返回一个异步迭代器对象中的 ```awaitable```` 结果。</div><div class="line">2. 一个异步迭代器必须实现 ```__anext__``` 方法（或者，使用 CPython C API 的 tp\_as\_async.am\_anext 定义）返回一个 ```awaitable```。</div><div class="line">3. 停止迭代器的 ```__anext__``` 必须抛出一个 ```StopAsyncIteration ``` 异常。</div><div class="line"></div><div class="line">一个异步迭代的例子：</div><div class="line"></div><div class="line">```python</div><div class="line">class AsyncIterable:</div><div class="line">    async def __aiter__(self):</div><div class="line">        return self</div><div class="line"></div><div class="line">    async def __anext__(self):</div><div class="line">        data = await self.fetch_data()</div><div class="line">        if data:</div><div class="line">            return data</div><div class="line">        else:</div><div class="line">            raise StopAsyncIteration</div><div class="line"></div><div class="line">    async def fetch_data(self):</div><div class="line">        ...</div></pre></td></tr></table></figure></h3><h4 id="新语法-1"><a href="#新语法-1" class="headerlink" title=" 新语法"></a><a name="Async-For-New-Syntax"></a> 新语法</h4><p>一种新的异步迭代方案被采纳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="keyword">for</span> TARGET <span class="keyword">in</span> ITER:</div><div class="line">    BLOCK</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    BLOCK2</div></pre></td></tr></table></figure>
<p>语义上等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iter = (ITER)</div><div class="line">iter = <span class="keyword">await</span> type(iter).__aiter__(iter)</div><div class="line">running = <span class="keyword">True</span></div><div class="line"><span class="keyword">while</span> running:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        TARGET = <span class="keyword">await</span> type(iter).__anext__(iter)</div><div class="line">    <span class="keyword">except</span> StopAsyncIteration:</div><div class="line">        running = <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        BLOCK</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    BLOCK2</div></pre></td></tr></table></figure>
<p>如果对一个普通的不含有 <figure class="highlight plain"><figcaption><span>方法的迭代器使用 ```async for```，会引发 ```TypeError``` 异常。如果在 ```async def``` 函数外使用 ```async for``` 会已发 ```SyntaxError``` 异常。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">和普通的 ```for``` 语法一样，```async for``` 有可选的 ```else``` 分支。</div><div class="line"></div><div class="line">#### &lt;a name=&quot;Async-For-Example-1&quot;&gt;&lt;/a&gt; 例子 1</div><div class="line"></div><div class="line">通过异步迭代器，就可以实现通过迭代实现异步缓冲数据：</div><div class="line"></div><div class="line">```python</div><div class="line">async for data in cursor:</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>当 <figure class="highlight plain"><figcaption><span>是一个异步迭代器时，就可以在 N 次迭代后从数据库中预取 N 行数据。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面的代码演示了新的异步迭代协议：</div><div class="line"></div><div class="line">```python</div><div class="line">class Cursor:</div><div class="line">    def __init__(self):</div><div class="line">        self.buffer = collections.deque()</div><div class="line"></div><div class="line">    async def _prefetch(self):</div><div class="line">        ...</div><div class="line"></div><div class="line">    async def __aiter__(self):</div><div class="line">        return self</div><div class="line"></div><div class="line">    async def __anext__(self):</div><div class="line">        if not self.buffer:</div><div class="line">            self.buffer = await self._prefetch()</div><div class="line">            if not self.buffer:</div><div class="line">                raise StopAsyncIteration</div><div class="line">        return self.buffer.popleft()</div></pre></td></tr></table></figure></p>
<p>那么这个 <figure class="highlight plain"><figcaption><span>类可以按照下面的方式使用：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```python</div><div class="line">async for row in Cursor():</div><div class="line">    print(row)</div></pre></td></tr></table></figure></p>
<p>这个等同于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i = <span class="keyword">await</span> Cursor().__aiter__()</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        row = <span class="keyword">await</span> i.__anext__()</div><div class="line">    <span class="keyword">except</span> StopAsyncIteration:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(row)</div></pre></td></tr></table></figure>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title=" 例子 2"></a><a name="Async-For-Example-2"></a> 例子 2</h4><p>下面的工具类用于将普通的迭代转换为异步。这个并没有什么实际的作用，这个代码只是用于演示普通迭代与异步迭代之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncIteratorWrapper</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        self._it = iter(obj)</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            value = next(self._it)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">raise</span> StopAsyncIteration</div><div class="line">        <span class="keyword">return</span> value</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="keyword">for</span> letter <span class="keyword">in</span> AsyncIteratorWrapper(<span class="string">"abc"</span>):</div><div class="line">    print(letter)</div></pre></td></tr></table></figure>
<h4 id="为什么使用"><a href="#为什么使用" class="headerlink" title=" 为什么使用 "></a><a name="Why-StopAsyncIteration"></a> 为什么使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">协程在内部实现中依旧是依赖于迭代器的。因此，在 [PEP-479](https://www.python.org/dev/peps/pep-0479) 生效之前，下面两者并没有区别：</div><div class="line"></div><div class="line">```python</div><div class="line">def g1():</div><div class="line">    yield from fut</div><div class="line">    return &apos;spam&apos;</div><div class="line">and</div><div class="line"></div><div class="line">def g2():</div><div class="line">    yield from fut</div><div class="line">    raise StopIteration(&apos;spam&apos;)</div></pre></td></tr></table></figure></h4><p>但是在 PEP 479 接受并且默认对协程开启时，下面的例子中的 <figure class="highlight plain"><figcaption><span>会被封装成 ```RuntimeError```。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```python</div><div class="line">async def a1():</div><div class="line">    await fut</div><div class="line">    raise StopIteration(&apos;spam&apos;)</div></pre></td></tr></table></figure></p>
<p>所以，想通知外部代码迭代已经结束，抛出一个 <figure class="highlight plain"><figcaption><span>异常的是不行的。因此，一个新的内置异常类 ```StopAsyncIteration ``` 被引入进来了。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">另外，根据 PEP 479，所有协程中抛出的 ```StopIteration``` 异常都会被封装成 ```RuntimeError```。</div><div class="line"></div><div class="line">### &lt;a name=&quot;Coroutine-objects&quot;&gt;&lt;/a&gt; 协程对象</div><div class="line">#### &lt;a name=&quot;Differences-from-generators&quot;&gt;&lt;/a&gt; 与生成器的不同之处</div><div class="line"></div><div class="line">这节进适用于 ```CO_COROUTINE``` 标记的原生协程，即，使用 ```async def``` 语法定义的对象。</div><div class="line"></div><div class="line">__现有的 asyncio 库中的 * 基于生成器的协程 * 的行为未做变更。__</div><div class="line"></div><div class="line">为了将协程与生成器区别开来，定义了下面的概念：</div><div class="line"></div><div class="line">1. 原生协程对象不实现 ```__iter__``` 和 ```__next__``` 方法。因此，他们不能够通过 ```iter()，list()，tuple()``` 和其他一些内置函数进行迭代。他们也不能用于 ```for...in``` 循环。   </div><div class="line">   在原生协程中尝试使用 ```__iter__``` 或者 ```__next``` 会触发 ```TypeError``` 异常。</div><div class="line">2. 未被装饰的生成器不能够 ```yield from``` 一个原生协程：这样会引发 ```TypeError```。</div><div class="line">3. 基于生成器的协程 (asyncio 代码必须使用 ```@asyncio.coroutine```) 可以 ```yield from``` 一个原生协程。</div><div class="line">4. 对原生协程对象和原生协程函数调用 ```inspect.isgenerator()``` 和 ```inspect.isgeneratorfunction()``` 会返回 False。</div><div class="line"></div><div class="line">#### &lt;a name=&quot;Coroutine-object-methods&quot;&gt;&lt;/a&gt; 协程对象方法</div><div class="line"></div><div class="line">协程内部基于生成器，因此他们同享实现过程。类似于生成器对象，协程包含 ```throw()```，```send()``` 和 ```close()``` 方法。```StopIteration``` 和 ```GeneratorExit``` 在协程中扮演者同样的角色（尽管 PEP 479 默认对协程开启了）。参考 [PEP-342](https://www.python.org/dev/peps/pep-0342), [PEP-380](https://www.python.org/dev/peps/pep-0380) 和 Python 文档了解更多细节。</div><div class="line"></div><div class="line">协程的 ```throw()``` 和 ```send()``` 方法可以用于将返回值和抛出异常推送到类似于 ```Future``` 的对象中。</div><div class="line"></div><div class="line">### &lt;a name=&quot;Debugging-Features&quot;&gt;&lt;/a&gt; 调试特性</div><div class="line"></div><div class="line">一个初学者普遍会犯的错误是忘记在协程中使用 ```yield from```。</div><div class="line"></div><div class="line">```python</div><div class="line">@asyncio.coroutine</div><div class="line">def useful():</div><div class="line">    asyncio.sleep(1) # this will do noting without &apos;yield from&apos;</div></pre></td></tr></table></figure></p>
<p>为了调试这类错误，asycio 提供了一种特殊的调试模式：装饰器 <figure class="highlight plain"><figcaption><span>封装所有的函数成一个特殊对象，这个对象的析构函数中记录警告。当封装的生成器垃圾回收时，会产生详细的记录信息，包括具体定义修饰函数、回收时的栈信息等等。封装对象同样提供一个 ```__repr__``` 函数用于输出关于生成器的详细信息。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">唯一的问题是如何启用这些调试功能。这些调试工具在生产模式中什么都不做，```@coroutine``` 修饰符在系统变量 ```PYTHONASYNCIODEBUG ``` 设置后才会提供调试功能。这种方式可以让 asyncio 程序使用 asyncio 自己的函数分析。```EventLoop.set_debug``` 是另外一个调试工具，他不会影响 ```@coroutine``` 修饰符行为。</div><div class="line"></div><div class="line">根据本提议，协程是原生的与生成器不同的概念。当抛出 ```RuntimeWarning``` 异常的协程是从来没有被 ```awaited``` 过的。因此添加了两条新的函数到 sys 模块：```set_coroutine_wrapper``` 和 ```get_coroutine_wrapper```。这个用于开启 asyncio 或者其他框架中的高级调试 (比如显示协程创建的位置和垃圾回收时的栈信息)。</div><div class="line"></div><div class="line">### &lt;a name=&quot;New-Standard-Library-Functions&quot;&gt;&lt;/a&gt; 新的标准库函数</div><div class="line"></div><div class="line">* ```types.coroutine(gen)```。参考 [types.coroutine()](#Type-Coroutine) 节中的内容。</div><div class="line">* ```inspect.iscoroutine(obj)``` 当 obj 是原生协程时返回 True。</div><div class="line">* ```inspect.iscoroutinefunction(obj)``` 当 obj 是原生协程函数时返回为 True。</div><div class="line">* ```inspect.isawaitable(obj)``` 当 obj 是 ```awaitable``` 时返回为 True。</div><div class="line">* ```inspect.getcoroutinestate(coro)``` 返回原生协程对象的当前状态（是 ```inspect.getfgeneratorstate(gen)``` 的镜像）。</div><div class="line">* ```inspect.getcoroutinelocals(coro)``` 返回原生协程对象的局部变量的映射（是 ```inspect.getgeneratorlocals(gen)``` 的镜像）。</div><div class="line">* ```sys.set_coroutine_wrapper(wrapper)``` 允许拦截原生协程对象的创建。```wrapper``` 必须是一个接受一个参数 ```callable```（一个协程对象），或者是 ```None```。```None``` 会重置 ```wrapper```。当调用第二次时，新的 ```wrapper``` 会替代之前的封装。这个函数是线程专有的。参考 [调度调试](#Debugging-Features) 了解更多细节。</div><div class="line">* ```sys.get_coroutine_wrapper()``` 返回当前的封装对象。如果封装未设置会返回 None。这个函数是线程专有的。参考 [调度调试](#Debugging-Features) 了解更多细节。</div><div class="line"></div><div class="line">### &lt;a name=&quot;New-Abstract-Base-Classes&quot;&gt;&lt;/a&gt; 新的抽象基类</div><div class="line"></div><div class="line">为了允许更好的与现有的框架（比如 Tornado）和编译器（比如 Cython）整合，我们添加了两个新的抽象基类 (ABC)：   </div><div class="line">```collections.abc.Awaitable``` 是 ```Future-like``` 类的抽象基类，它实现了 ```__await__``` 方法。   </div><div class="line">```collections.abc.Coroutine``` 是协程对象的抽象基类，它实现了 ```send(value)```，```throw(type, exc, tb)```，```close()``` 和 ```__await__()``` 方法。</div><div class="line"></div><div class="line">值得注意的是，带有 ```CO_ITERABLE_COROUTINE``` 标记的基于生成器的协程并没有实现 ```__await__``` 方法，因此他不是 ```collections.abc.Coroutine``` 和 ```collections.abc.Awaitable``` 抽象类的实例：</div><div class="line"></div><div class="line">```python</div><div class="line">@types.coroutine</div><div class="line">def gencoro():</div><div class="line">    yield</div><div class="line"></div><div class="line">assert not isinstance(gencoro(), collections.abc.Coroutine)</div><div class="line"></div><div class="line"># 然而:</div><div class="line">assert inspect.isawaitable(gencoro())</div></pre></td></tr></table></figure></p>
<p>为了方便对异步迭代的调试，添加了另外两个抽象基类：</p>
<ul>
<li><figure class="highlight plain"><figcaption><span>-- 用于测试 ```__aiter__``` 方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* ```collections.abc.AsyncIterator``` -- 用于测试 ```__aiter__``` 和 ```__anext__``` 方法。</div><div class="line"></div><div class="line">## &lt;a name=&quot;Glossary&quot;&gt;&lt;/a&gt; 专用术语表   </div><div class="line">## &lt;a name=&quot;List-of-functions-and-methods&quot;&gt;&lt;/a&gt; 函数与方法列表   </div><div class="line">## &lt;a name=&quot;Transition-Plan&quot;&gt;&lt;/a&gt; 移植计划</div><div class="line">### &lt;a name=&quot;Backwards-Compatibility&quot;&gt;&lt;/a&gt; 向后兼容性</div><div class="line">#### &lt;a name=&quot;asyncio&quot;&gt;&lt;/a&gt;asyncio</div><div class="line">#### &lt;a name=&quot;asyncio-migration-strategy&quot;&gt;&lt;/a&gt;asyncio 移植策略</div><div class="line">#### &lt;a name=&quot;async-await-in-CPython-code-base&quot;&gt;&lt;/a&gt;CPython 代码中的 ```async/await</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="语法更新"><a href="#语法更新" class="headerlink" title=" 语法更新"></a><a name="Grammar-Updates"></a> 语法更新</h3><h3 id="失效计划"><a href="#失效计划" class="headerlink" title=" 失效计划"></a><a name="Deprecation-Plans"></a> 失效计划</h3><h2 id="性能"><a href="#性能" class="headerlink" title=" 性能"></a><a name="Performance"></a> 性能</h2><h3 id="总体影响"><a href="#总体影响" class="headerlink" title=" 总体影响"></a><a name="Overall-Impact"></a> 总体影响</h3><p>这个提议并不会造成性能影响。这是 Python 官方性能测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">python perf.py -r -b default ../cpython/python.exe ../cpython-aw/python.exe</div><div class="line"></div><div class="line">[skipped]</div><div class="line"></div><div class="line">Report on Darwin ysmac 14.3.0 Darwin Kernel Version 14.3.0:</div><div class="line">Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64</div><div class="line">x86_64 i386</div><div class="line"></div><div class="line">Total CPU cores: 8</div><div class="line"></div><div class="line">### etree_iterparse ###</div><div class="line">Min: 0.365359 -&gt; 0.349168: 1.05x faster</div><div class="line">Avg: 0.396924 -&gt; 0.379735: 1.05x faster</div><div class="line">Significant (t=9.71)</div><div class="line">Stddev: 0.01225 -&gt; 0.01277: 1.0423x larger</div><div class="line"></div><div class="line">The following not significant results are hidden, use -v to show them:</div><div class="line">django_v2, 2to3, etree_generate, etree_parse, etree_process, fastpickle,</div><div class="line">fastunpickle, json_dump_v2, json_load, nbody, regex_v8, tornado_http.</div></pre></td></tr></table></figure>
<h3 id="编译器修改"><a href="#编译器修改" class="headerlink" title=" 编译器修改"></a><a name="Tokenizer-modifications"></a> 编译器修改</h3><p>修改后的编译器处理 Python 文件没有明显的性能下降：处理 12MB 大小的文件（<figure class="highlight plain"><figcaption><span>重复 1000 次）消耗时间相同。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### &lt;a name=&quot;async-await&quot;&gt;&lt;/a&gt;```async/await</div></pre></td></tr></table></figure></p>
<p>下面的小测试用于检测『async』函数和生成器的性能差异：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    l = <span class="keyword">yield</span> <span class="keyword">from</span> binary(n - <span class="number">1</span>)</div><div class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> binary(n - <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> l + <span class="number">1</span> + r</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">abinary</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    l = <span class="keyword">await</span> abinary(n - <span class="number">1</span>)</div><div class="line">    r = <span class="keyword">await</span> abinary(n - <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> l + <span class="number">1</span> + r</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func, depth, repeat)</span>:</span></div><div class="line">    t0 = time.time()</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(repeat):</div><div class="line">        o = func(depth)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                o.send(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">pass</span></div><div class="line">    t1 = time.time()</div><div class="line">    print(<span class="string">'&#123;&#125;(&#123;&#125;) * &#123;&#125;: total &#123;:.3f&#125;s'</span>.format(func.__name__, depth, repeat, t1-t0))</div></pre></td></tr></table></figure>
<p>结果显示并没有明显的性能差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">binary(19) * 30: total 53.321s</div><div class="line">abinary(19) * 30: total 55.073s</div><div class="line"></div><div class="line">binary(19) * 30: total 53.361s</div><div class="line">abinary(19) * 30: total 51.360s</div><div class="line"></div><div class="line">binary(19) * 30: total 49.438s</div><div class="line">abinary(19) * 30: total 51.047s</div></pre></td></tr></table></figure>
<p>注意：19 层意味着 1,048,575 调用。</p>
<h2 id="实现参考"><a href="#实现参考" class="headerlink" title=" 实现参考"></a><a name="Reference-Implementation"></a> 实现参考</h2><p>实现参考可以在 <a href="https://github.com/1st1/cpython/tree/await" target="_blank" rel="external">这里</a> 找到。</p>
<h3 id="上层修改和新协议列表"><a href="#上层修改和新协议列表" class="headerlink" title=" 上层修改和新协议列表"></a><a name="List-of-high-level-changes-and-new-protocols"></a> 上层修改和新协议列表</h3><ol>
<li>新的协程定义语法：<figure class="highlight plain"><figcaption><span>def``` 和新的 ```await``` 关键字。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">2. ```Future-like``` 对象提供新的 ```__await__``` 方法和新的 ```PyTypeObject ``` 的 ```tp_as_async.am_await```。</div><div class="line">3. 新的异步上下文管理器语法： ```async with```，协议提供了 ```__aenter__``` 和 ```__aexit__``` 方法。</div><div class="line">4. 新的异步迭代语法：```async for```，协议提供了 ```__aiter```、```__aexit``` 和新的内置异常 ```StopAsyncIteration```。```PyTypeObject``` 提供了新的 ```tp_as_async.am_aiter``` 和 ```tp_as_async.am_anext```。</div><div class="line">5. 新的 AST 节点：```AsyncFunctionDef```，```AsyncFor```，```AsyncWith``` 和 ```Await```。</div><div class="line">6. 新函数 ```sys.set_coroutine_wrapper(callback)```，```sys.get_coroutine_wrapper()```，```types.coroutine(gen)```，```inspect.iscoroutinefunction(func)```，```inspect.iscoroutine(obj)```，```inspect.isawaitable(obj)```，```inspect.getcoroutinestate(coro)``` 和 ```inspect.getcoroutinelocals(coro)```。</div><div class="line">7. 新的代码对象标记 ```CO_COROUTINE``` 和 ```CO_ITERABLE_COROUTINE```。</div><div class="line">8. 新的抽象基类 ```collections.abc.Awaitable```，```collections.abc.Coroutine```，```collections.abc.AsyncIterable``` 和 ```collections.abc.AsyncIterator```。</div><div class="line">9. C API 变更：新的 ```PyCoro_Type```（将 Python 作为 ```types.CoroutineType``` 输出）和 ```PyCoroObject```。```PyCoro_CheckExact(*o)``` 用于检测 o 是否为原生协程。</div><div class="line"></div><div class="line">虽然变化和新内容列表并不短，但是重要的是理解：大部分用户不会直接使用这些特性。他的目的是在于框架和库能够使用这些为用户提供便捷的使用和明确的 API 用于 ```async def```，```await```，```async for``` 和 ```async with``` 语法。</div><div class="line"></div><div class="line">### &lt;a name=&quot;working-example&quot;&gt;&lt;/a&gt; 可以工作的实例</div><div class="line"></div><div class="line">本 PEP 提出的所有概念都 [已经实现](https://github.com/1st1/cpython/tree/await)，并且可以被测试。</div><div class="line"></div><div class="line">```python</div><div class="line">import asyncio</div><div class="line"></div><div class="line">async def echo_server():</div><div class="line">    print(&apos;Serving on localhost:8000&apos;)</div><div class="line">    await asyncio.start_server(handle_connection,&apos;localhost&apos;, 8000)</div><div class="line"></div><div class="line">async def handle_connection(reader, writer):</div><div class="line">    print(&apos;New connection...&apos;)</div><div class="line"></div><div class="line">    while True:</div><div class="line">        data = await reader.read(8192)</div><div class="line"></div><div class="line">        if not data:</div><div class="line">            break</div><div class="line"></div><div class="line">        print(&apos;Sending &#123;:.10&#125;... back&apos;.format(repr(data)))</div><div class="line">        writer.write(data)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(echo_server())</div><div class="line">try:</div><div class="line">    loop.run_forever()</div><div class="line">finally:</div><div class="line">    loop.close()</div></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/async/" rel="tag"># async</a>
          
            <a href="/tags/PEPs/" rel="tag"># PEPs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/10/write-aio-python-redis-client-as-dummy-2/" rel="next" title="从零实现一个 Redis 客户端（二）">
                <i class="fa fa-chevron-left"></i> 从零实现一个 Redis 客户端（二）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/11/async-python/" rel="prev" title="Python 异步与性能迷思">
                Python 异步与性能迷思 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/363344?v=3&s=460"
               alt="ipfans" />
          <p class="site-author-name" itemprop="name">ipfans</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ipfans" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/janxin" target="_blank" title="Tw1tter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Tw1tter
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.yeeuu.com" title="杭州云柚科技" target="_blank">杭州云柚科技</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#新语法"><span class="nav-number">1.</span> <span class="nav-text"> 新语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步迭代器与"><span class="nav-number"></span> <span class="nav-text"> 异步迭代器与 for```1234567891011121314151617181920212223一个异步迭代器能够在它的迭代实现里调用异步代码，也可以在它的 ```__next__``` 方法里调用异步代码。为了支持异步迭代，需要：1. 一个对象必须实现 ```__aiter__``` 方法（或者，使用 CPython C API 的 tp\_as\_async.am\_aiter 定义），返回一个异步迭代器对象中的 ```awaitable```` 结果。2. 一个异步迭代器必须实现 ```__anext__``` 方法（或者，使用 CPython C API 的 tp\_as\_async.am\_anext 定义）返回一个 ```awaitable```。3. 停止迭代器的 ```__anext__``` 必须抛出一个 ```StopAsyncIteration ``` 异常。一个异步迭代的例子：```pythonclass AsyncIterable:    async def __aiter__(self):        return self    async def __anext__(self):        data = await self.fetch_data()        if data:            return data        else:            raise StopAsyncIteration    async def fetch_data(self):        ...</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新语法-1"><span class="nav-number">1.</span> <span class="nav-text"> 新语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子-2"><span class="nav-number">2.</span> <span class="nav-text"> 例子 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用"><span class="nav-number">3.</span> <span class="nav-text"> 为什么使用 123456789101112协程在内部实现中依旧是依赖于迭代器的。因此，在 [PEP-479](https://www.python.org/dev/peps/pep-0479) 生效之前，下面两者并没有区别：```pythondef g1():    yield from fut    return 'spam'anddef g2():    yield from fut    raise StopIteration('spam')</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法更新"><span class="nav-number"></span> <span class="nav-text"> 语法更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#失效计划"><span class="nav-number"></span> <span class="nav-text"> 失效计划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能"><span class="nav-number"></span> <span class="nav-text"> 性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总体影响"><span class="nav-number"></span> <span class="nav-text"> 总体影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器修改"><span class="nav-number"></span> <span class="nav-text"> 编译器修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现参考"><span class="nav-number"></span> <span class="nav-text"> 实现参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上层修改和新协议列表"><span class="nav-number"></span> <span class="nav-text"> 上层修改和新协议列表</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ipfans</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://s1mbily.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://ipfans.github.io/2015/10/coroutines-with-async-and-await-syntax-chinese/';
          this.page.identifier = '2015/10/coroutines-with-async-and-await-syntax-chinese/';
          this.page.title = 'PEP 0492 Coroutines with async and await syntax 中文翻译';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://s1mbily.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  





  

  

  

  

  

  

</body>
</html>
